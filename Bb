import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
public class KafkaProducerService {

    private static final int MIN_PARTITION = 12;
    private static final int MAX_PARTITION = 24;

    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    /**
     * Calculates the partition dynamically based on the message value.
     *
     * @param value The message value.
     * @return The partition number.
     */
    private int calculatePartition(String value) {
        if (value == null || value.isEmpty()) {
            throw new IllegalArgumentException("Message value cannot be null or empty");
        }

        int hashCode = value.hashCode();
        int range = MAX_PARTITION - MIN_PARTITION;
        return MIN_PARTITION + (Math.abs(hashCode) % range);
    }

    /**
     * Sends a message to a specific partition based on its calculated value.
     *
     * @param topic   The Kafka topic.
     * @param message The message to send.
     */
    public void sendMessage(String topic, String message) {
        int partition = calculatePartition(message);
        kafkaTemplate.send(topic, partition, null, message);
        System.out.printf("Sent message: %s to partition: %d%n", message, partition);
    }
}

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class KafkaProducerRunner implements CommandLineRunner {

    @Autowired
    private KafkaProducerService kafkaProducerService;

    @Override
    public void run(String... args) {
        String topic = "your-topic";

        String[] messages = {"Message1", "Message2", "Message3", "Message4"};
        for (String message : messages) {
            kafkaProducerService.sendMessage(topic, message);
        }
    }
}

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.Duration;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class SyncService {

    @Autowired
    private CollectionARepository collectionARepository;

    @Autowired
    private CollectionBRepository collectionBRepository;

    // Scheduled to run every 30 minutes
    @Scheduled(fixedRate = 30 * 60 * 1000) // 30 minutes
    public void syncData() {
        // Calculate the time range (last 35 minutes)
        Instant now = Instant.now();
        Instant thirtyFiveMinutesAgo = now.minus(Duration.ofMinutes(35));

        // Fetch data from Collection A and Collection B
        List<DocumentA> recentDocsA = collectionARepository.findDocumentsByTimeRange(thirtyFiveMinutesAgo, now);
        List<DocumentB> recentDocsB = collectionBRepository.findDocumentsByTimeRange(thirtyFiveMinutesAgo, now);

        // Convert Collection B documents to a set of messageIds for quick lookup
        Set<String> messageIdsB = recentDocsB.stream()
                                             .map(DocumentB::getMessageId)
                                             .collect(Collectors.toSet());

        // Find documents from Collection A that don't have corresponding entries in Collection B
        List<DocumentA> toBeSynced = recentDocsA.stream()
                                                .filter(doc -> !messageIdsB.contains(doc.getMessageId()))
                                                .collect(Collectors.toList());

        // Process the documents that need to be synced
        syncDocuments(toBeSynced);
    }

    // Logic for syncing documents (could be a DB update or any other operation)
    private void syncDocuments(List<DocumentA> toBeSynced) {
        // Implement the logic to sync or update the documents
        for (DocumentA docA : toBeSynced) {
            // For example, you might trigger an endpoint, or update Collection B with the missing data
            System.out.println("Syncing document with messageId: " + docA.getMessageId());
            // For example, you could save or update documents in Collection B
            // collectionBRepository.save(convertToDocumentB(docA));
        }
    }
}
