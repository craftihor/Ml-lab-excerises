import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
public class YourSchedulerService {

    @Autowired
    private YourRepository yourRepository;

    @Scheduled(fixedRate = 60000) // Run every 60 seconds
    public void fetchAndProcessData() {
        // Fetch records with status "pending"
        List<YourEntity> pendingRecords = yourRepository.findByStatus("pending");

        // Process all entities in parallel
        List<CompletableFuture<Void>> futures = pendingRecords.stream()
                .map(entity -> CompletableFuture.runAsync(() -> processAndSaveEntity(entity)))
                .collect(Collectors.toList());

        // Wait for all tasks to complete
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        System.out.println("All entities processed.");
    }

    private void processAndSaveEntity(YourEntity entity) {
        try {
            // Call the asynchronous processing function
            processEntity(entity);

            // Update the status to "processed" after processing
            entity.setStatus("processed");
            yourRepository.save(entity);

            System.out.println("Processed entity with ID: " + entity.getId());
        } catch (Exception e) {
            System.err.println("Error processing entity with ID: " + entity.getId() + " - " + e.getMessage());
        }
    }

    private void processEntity(YourEntity entity) {
        // Simulate async processing (replace with your actual async logic)
        try {
            Thread.sleep(1000); // Simulating delay
            System.out.println("Asynchronously processing entity with ID: " + entity.getId());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
