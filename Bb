import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.test.util.ReflectionTestUtils;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Date;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class XmlToCsvConverterTest {

    @InjectMocks
    private XmlToCsvConverter converter;

    @Mock
    private XmRestClient xmRestClient;

    @TempDir
    Path tempDir;

    private String xmlFilePath;
    private String csvFilePath;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        xmlFilePath = tempDir.resolve("xml").toString();
        csvFilePath = tempDir.resolve("csv").toString();
        new File(xmlFilePath).mkdirs();
        new File(csvFilePath).mkdirs();

        ReflectionTestUtils.setField(converter, "xmlFilePath", xmlFilePath);
        ReflectionTestUtils.setField(converter, "csvFilePath", csvFilePath);
    }

    @Test
    void testConvertXmlToCsv() throws Exception {
        // Prepare test data
        String filename = "test.xml";
        String xmlContent = "<root tmstmp=\"2024-09-24T10:00:00\"><data>Test</data></root>";
        Files.write(Path.of(xmlFilePath, filename), xmlContent.getBytes());

        JsonObject template = new JsonParser().parse(
            "{\"fields\":{\"field1\":{\"position\":1,\"xpath\":\"/root/data\"}},\"end_tag\":\"root\"}"
        ).getAsJsonObject();

        when(xmRestClient.exceptionMetadata(filename)).thenReturn(template);

        // Execute
        converter.convertXmlToCsv(filename, template);

        // Verify
        String csvFilename = filename.replace(".xml", "") + "_" + 
            new SimpleDateFormat("yyyy-MM-dd").format(new Date(System.currentTimeMillis() - 24*60*60*1000)) + ".csv";
        Path csvPath = Path.of(csvFilePath, csvFilename);
        assertTrue(Files.exists(csvPath), "CSV file should be created");

        String csvContent = Files.readString(csvPath);
        assertTrue(csvContent.contains("Test"), "CSV should contain data from XML");
    }

    @Test
    void testConvertXmlToCsv_FileRejectedException() throws Exception {
        // Prepare test data
        String filename = "old.xml";
        String oldDate = new SimpleDateFormat("yyyy-MM-dd").format(new Date(System.currentTimeMillis() - 48*60*60*1000));
        String xmlContent = "<root tmstmp=\"" + oldDate + "T10:00:00\"><data>Old</data></root>";
        Files.write(Path.of(xmlFilePath, filename), xmlContent.getBytes());

        JsonObject template = new JsonParser().parse(
            "{\"fields\":{\"field1\":{\"position\":1,\"xpath\":\"/root/data\"}},\"end_tag\":\"root\"}"
        ).getAsJsonObject();

        // Execute and verify
        assertThrows(FileRejectedException.class, () -> converter.convertXmlToCsv(filename, template));
    }

    @Test
    void testProcess() throws Exception {
        // Prepare test data
        String filename = "test.xml";
        JsonObject template = new JsonParser().parse(
            "{\"fields\":{\"field1\":{\"position\":1,\"xpath\":\"/root/data\"}},\"end_tag\":\"root\"}"
        ).getAsJsonObject();

        when(xmRestClient.exceptionMetadata(filename)).thenReturn(template);

        Exchange exchange = mock(Exchange.class);
        Message message = mock(Message.class);
        when(exchange.getIn()).thenReturn(message);
        when(message.getHeader(Exchange.FILE_NAME, String.class)).thenReturn(filename);

        // Execute
        converter.process(exchange);

        // Verify
        verify(message).setHeader("process", false);
        verify(message).setHeader("process", true);
        verify(xmRestClient).exceptionMetadata(filename);
    }
}
