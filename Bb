moimport com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.List;

@Service
public class XmlToCsvService {

    @Value("${xml.file.path}")
    private String xmlFilePath;

    @Value("${csv.output.path}")
    private String csvOutputPath;

    @Value("${mongo.connection.string}")
    private String mongoConnectionString;

    @Value("${mongo.database.name}")
    private String mongoDatabaseName;

    @Value("${mongo.collection.name}")
    private String mongoCollectionName;

    public void convertXmlToCsv() throws Exception {
        // Load field mapping from MongoDB
        List<Document> fieldMappings = loadFieldMappingFromMongo();

        // Load XML document
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
        Document doc = dBuilder.parse(new File(xmlFilePath));
        doc.getDocumentElement().normalize();

        try (FileWriter writer = new FileWriter(csvOutputPath)) {
            // Write headers
            List<String> headers = getHeaders(fieldMappings);
            writer.write(String.join("|", headers) + "\n");

            // Loop through each SecLendCommissSection element in the XML
            NodeList sectionNodes = doc.getElementsByTagName("SecLendCommissSection");
            for (int i = 0; i < sectionNodes.getLength(); i++) {
                Element sectionElement = (Element) sectionNodes.item(i);
                String secInstr = getElementValue(sectionElement, "SecInstr");

                NodeList detailNodes = sectionElement.getElementsByTagName("SecLendCommissDetl");
                for (int j = 0; j < detailNodes.getLength(); j++) {
                    Element detailElement = (Element) detailNodes.item(j);

                    List<String> rowData = new ArrayList<>();
                    for (Document fieldMapping : fieldMappings) {
                        String value = "";
                        String xmlTag = fieldMapping.getString("xmlTag");
                        String attribute = fieldMapping.getString("attribute");

                        if (!xmlTag.isEmpty()) {
                            value = getElementValue(detailElement, xmlTag);
                        } else if (!attribute.isEmpty()) {
                            value = detailElement.getAttribute(attribute);
                        }

                        // Handle retaining common fields
                        if (xmlTag.equals("SecInstr")) {
                            value = secInstr;
                        }

                        rowData.add(value);
                    }
                    writer.write(String.join("|", rowData) + "\n");
                }
            }
        }
    }

    private List<Document> loadFieldMappingFromMongo() {
        MongoDatabase database = MongoClients.create(mongoConnectionString).getDatabase(mongoDatabaseName);
        MongoCollection<Document> collection = database.getCollection(mongoCollectionName);
        return collection.find().into(new ArrayList<>());
    }

    private String getElementValue(Element element, String tagName) {
        NodeList nodeList = element.getElementsByTagName(tagName);
        return (nodeList.getLength() > 0) ? nodeList.item(0).getTextContent() : "";
    }

    private List<String> getHeaders(List<Document> fieldMappings) {
        List<String> headers = new ArrayList<>();
        for (Document fieldMapping : fieldMappings) {
            headers.add(fieldMapping.getString("csvHeader"));
        }
        return headers;
    }
}

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileWriter;
import java.util.HashMap;
import java.util.Map;

public class XMLToCSVFlattener {

    public static void main(String[] args) {
        try {
            // Parse the XML file
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse("input.xml");
            Element root = doc.getDocumentElement();

            // Prepare CSV writer
            FileWriter out = new FileWriter("output.csv");
            CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT.withHeader());

            // Flatten XML
            flattenXML(root, new HashMap<>(), printer);

            // Close CSV writer
            printer.flush();
            printer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void flattenXML(Element element, Map<String, String> parentData, CSVPrinter printer) throws Exception {
        Map<String, String> currentData = new HashMap<>(parentData);

        // Process element attributes
        for (int i = 0; i < element.getAttributes().getLength(); i++) {
            Node attr = element.getAttributes().item(i);
            currentData.put(element.getTagName() + "@" + attr.getNodeName(), attr.getNodeValue());
        }

        // Process child elements
        NodeList childNodes = element.getChildNodes();
        boolean hasChildElements = false;

        for (int i = 0; i < childNodes.getLength(); i++) {
            Node node = childNodes.item(i);

            if (node.getNodeType() == Node.ELEMENT_NODE) {
                hasChildElements = true;
                flattenXML((Element) node, currentData, printer);
            } else if (node.getNodeType() == Node.TEXT_NODE) {
                String text = node.getTextContent().trim();
                if (!text.isEmpty()) {
                    currentData.put(element.getTagName(), text);
                }
            }
        }

        if (!hasChildElements) {
            printer.printRecord(currentData.values());
        }
    }
}


import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileWriter;
import java.util.LinkedHashMap;
import java.util.Map;

public class XMLToCSVWithXPath {

    public static void main(String[] args) {
        try {
            // Parse the XML file
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse("input.xml");
            Element root = doc.getDocumentElement();

            // Prepare CSV writer
            FileWriter out = new FileWriter("output.csv");
            CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);

            // Flatten XML
            Map<String, String> xPathMap = new LinkedHashMap<>();
            flattenXML(root, "", xPathMap, printer);

            // Write headers
            printer.printRecord(xPathMap.keySet());

            // Write data
            printer.printRecord(xPathMap.values());

            // Close CSV writer
            printer.flush();
            printer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void flattenXML(Element element, String currentPath, Map<String, String> xPathMap, CSVPrinter printer) throws Exception {
        String newPath = currentPath.isEmpty() ? element.getTagName() : currentPath + "/" + element.getTagName();

        // Process element attributes
        for (int i = 0; i < element.getAttributes().getLength(); i++) {
            Node attr = element.getAttributes().item(i);
            String attrPath = newPath + "/@" + attr.getNodeName();
            xPathMap.put(attrPath, attr.getNodeValue());
        }

        // Process child elements
        NodeList childNodes = element.getChildNodes();
        boolean hasChildElements = false;

        for (int i = 0; i < childNodes.getLength(); i++) {
            Node node = childNodes.item(i);

            if (node.getNodeType() == Node.ELEMENT_NODE) {
                hasChildElements = true;
                flattenXML((Element) node, newPath, xPathMap, printer);
            } else if (node.getNodeType() == Node.TEXT_NODE) {
                String text = node.getTextContent().trim();
                if (!text.isEmpty()) {
                    xPathMap.put(newPath, text);
                }
            }
        }

        if (!hasChildElements) {
            // Write the row to the CSV for the current element if it is a leaf node
            printer.printRecord(xPathMap.values());
        }
    }
}
