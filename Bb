import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.mongodb.BasicDBObject;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Predicate;

public class ConditionalJsonParser {

    public static void main(String[] args) throws IOException {
        // Example JSON input
        String jsonString = "{ \"root\": { \"payload\": { \"BCSettlementTransaction\": { \"originatingSource\": { \"system\": { \"id\": [ { \"type\": \"otherType\", \"value\": \"12345\" }, { \"type\": \"bcPublisherSystem\", \"value\": \"67890\" } ], \"name\": \"SystemNameExample\" } }, \"transactionDetails\": { \"transactionId\": \"txn123456\", \"amount\": 1000 } } } } }";

        // Define field mappings with conditions
        Map<String, FieldConfig> fieldConfigs = new HashMap<>();
        fieldConfigs.put("systemId", new FieldConfig(
            "/root/payload/BCSettlementTransaction/originatingSource/system/id",
            node -> "bcPublisherSystem".equals(node.get("type").asText()),  // Condition: type == "bcPublisherSystem"
            "value"  // Field to extract if condition is met
        ));
        
        fieldConfigs.put("transactionId", new FieldConfig(
            "/root/payload/BCSettlementTransaction/transactionDetails/transactionId",
            null,  // No condition for a simple field
            null
        ));
        
        fieldConfigs.put("amount", new FieldConfig(
            "/root/payload/BCSettlementTransaction/transactionDetails/amount",
            null,  // No condition for a simple field
            null
        ));
        
        BasicDBObject basicDBObject = extractFieldsWithConditions(jsonString, fieldConfigs);
        
        System.out.println("Resulting BasicDBObject: " + basicDBObject);
    }

    private static BasicDBObject extractFieldsWithConditions(String jsonString, Map<String, FieldConfig> fieldConfigs) throws IOException {
        BasicDBObject basicDBObject = new BasicDBObject();
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode rootNode = objectMapper.readTree(jsonString);

        for (Map.Entry<String, FieldConfig> entry : fieldConfigs.entrySet()) {
            String fieldName = entry.getKey();
            FieldConfig config = entry.getValue();

            // Traverse JSON based on the path specified in FieldConfig
            JsonNode node = rootNode.at(config.jsonPath.replace("/", "/"));

            // Check if the node is found and apply the condition if present
            if (!node.isMissingNode()) {
                if (node.isArray()) {
                    for (JsonNode item : node) {
                        if (config.condition == null || config.condition.test(item)) {
                            basicDBObject.put(fieldName, config.subField != null ? item.get(config.subField).asText() : item.asText());
                            break;
                        }
                    }
                } else {
                    basicDBObject.put(fieldName, config.subField != null ? node.get(config.subField).asText() : node.asText());
                }
            }
        }
        return basicDBObject;
    }

    // Helper class to store each field's JSON path, condition, and target subfield
    static class FieldConfig {
        String jsonPath;
        Predicate<JsonNode> condition;
        String subField; // the field within a matched node to extract

        public FieldConfig(String jsonPath, Predicate<JsonNode> condition, String subField) {
            this.jsonPath = jsonPath;
            this.condition = condition;
            this.subField = subField;
        }
    }
}



import com.jayway.jsonpath.JsonPath; import com.jayway.jsonpath.ReadContext; import java.io.File; import java.nio.file.Files; import java.util.List; import java.util.Map; import java.util.HashMap; public class JsonXPathParser { private ReadContext jsonContext; private Map<String, Object> resultMap; public JsonXPathParser() { this.resultMap = new HashMap<>(); } public void loadJsonFromFile(String filePath) throws Exception { String jsonContent = new String(Files.readAllBytes(new File(filePath).toPath())); this.jsonContext = JsonPath.parse(jsonContent); } public void loadJsonFromString(String jsonString) { this.jsonContext = JsonPath.parse(jsonString); } public void addFieldToMap(String fieldName, String jsonPath) { try { Object value = jsonContext.read(jsonPath); resultMap.put(fieldName, value); } catch (Exception e) { System.err.println("Error reading path: " + jsonPath + " - " + e.getMessage()); } } public Map<String, Object> getResultMap() { return resultMap; } public static void main(String[] args) { // Example JSON String jsonString = """ { "store": { "book": [ { "category": "reference", "author": "Nigel Rees", "title": "Sayings of the Century", "price": 8.95 }, { "category": "fiction", "author": "J.R.R. Tolkien", "title": "The Lord of the Rings", "price": 22.99 } ], "bicycle": { "color": "red", "price": 19.95 } }, "expensive": 10 } """; JsonXPathParser parser = new JsonXPathParser(); parser.loadJsonFromString(jsonString); // Using JsonPath expressions to extract data parser.addFieldToMap("allAuthors", "$.store.book[*].author"); // Get all authors parser.addFieldToMap("firstBook", "$.store.book[0]"); // Get first book parser.addFieldToMap("expensiveBooks", "$.store.book[?(@.price > 20)]"); // Get books over $20 parser.addFieldToMap("bookTitles", "$.store.book[*].title"); // Get all book titles parser.addFieldToMap("bicycleColor", "$.store.bicycle.color"); // Get bicycle color parser.addFieldToMap("expensiveLimit", "$.expensive"); // Get expensive limit // Print results Map<String, Object> results = parser.getResultMap(); results.forEach((key, value) -> { System.out.println(key + ":"); if (value instanceof List) { ((List<?>) value).forEach(item -> System.out.println("\t" + item)); } else { System.out.println("\t" + value); } }); // Example of advanced JsonPath queries try { // Find all books with price less than expensive limit List<Map<String, Object>> affordableBooks = JsonPath.parse(jsonString) .read("$.store.book[?(@.price < $.expensive)]"); System.out.println("\nAffordable books:"); affordableBooks.forEach(book -> System.out.println("\t" + book)); // Calculate average book price List<Double> prices = JsonPath.parse(jsonString) .read("$.store.book[*].price"); double avgPrice = prices.stream() .mapToDouble(Double::valueOf) .average() .orElse(0.0); System.out.println("\nAverage book price: " + avgPrice); } catch (Exception e) { e.printStackTrace(); } } }
