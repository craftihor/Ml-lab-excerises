moimport com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.List;

@Service
public class XmlToCsvService {

    @Value("${xml.file.path}")
    private String xmlFilePath;

    @Value("${csv.output.path}")
    private String csvOutputPath;

    @Value("${mongo.connection.string}")
    private String mongoConnectionString;

    @Value("${mongo.database.name}")
    private String mongoDatabaseName;

    @Value("${mongo.collection.name}")
    private String mongoCollectionName;

    public void convertXmlToCsv() throws Exception {
        // Load field mapping from MongoDB
        List<Document> fieldMappings = loadFieldMappingFromMongo();

        // Load XML document
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
        Document doc = dBuilder.parse(new File(xmlFilePath));
        doc.getDocumentElement().normalize();

        try (FileWriter writer = new FileWriter(csvOutputPath)) {
            // Write headers
            List<String> headers = getHeaders(fieldMappings);
            writer.write(String.join("|", headers) + "\n");

            // Loop through each SecLendCommissSection element in the XML
            NodeList sectionNodes = doc.getElementsByTagName("SecLendCommissSection");
            for (int i = 0; i < sectionNodes.getLength(); i++) {
                Element sectionElement = (Element) sectionNodes.item(i);
                String secInstr = getElementValue(sectionElement, "SecInstr");

                NodeList detailNodes = sectionElement.getElementsByTagName("SecLendCommissDetl");
                for (int j = 0; j < detailNodes.getLength(); j++) {
                    Element detailElement = (Element) detailNodes.item(j);

                    List<String> rowData = new ArrayList<>();
                    for (Document fieldMapping : fieldMappings) {
                        String value = "";
                        String xmlTag = fieldMapping.getString("xmlTag");
                        String attribute = fieldMapping.getString("attribute");

                        if (!xmlTag.isEmpty()) {
                            value = getElementValue(detailElement, xmlTag);
                        } else if (!attribute.isEmpty()) {
                            value = detailElement.getAttribute(attribute);
                        }

                        // Handle retaining common fields
                        if (xmlTag.equals("SecInstr")) {
                            value = secInstr;
                        }

                        rowData.add(value);
                    }
                    writer.write(String.join("|", rowData) + "\n");
                }
            }
        }
    }

    private List<Document> loadFieldMappingFromMongo() {
        MongoDatabase database = MongoClients.create(mongoConnectionString).getDatabase(mongoDatabaseName);
        MongoCollection<Document> collection = database.getCollection(mongoCollectionName);
        return collection.find().into(new ArrayList<>());
    }

    private String getElementValue(Element element, String tagName) {
        NodeList nodeList = element.getElementsByTagName(tagName);
        return (nodeList.getLength() > 0) ? nodeList.item(0).getTextContent() : "";
    }

    private List<String> getHeaders(List<Document> fieldMappings) {
        List<String> headers = new ArrayList<>();
        for (Document fieldMapping : fieldMappings) {
            headers.add(fieldMapping.getString("csvHeader"));
        }
        return headers;
    }
}

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileWriter;
import java.util.HashMap;
import java.util.Map;

public class XMLToCSVFlattener {

    public static void main(String[] args) {
        try {
            // Parse the XML file
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse("input.xml");
            Element root = doc.getDocumentElement();

            // Prepare CSV writer
            FileWriter out = new FileWriter("output.csv");
            CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT.withHeader());

            // Flatten XML
            flattenXML(root, new HashMap<>(), printer);

            // Close CSV writer
            printer.flush();
            printer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void flattenXML(Element element, Map<String, String> parentData, CSVPrinter printer) throws Exception {
        Map<String, String> currentData = new HashMap<>(parentData);

        // Process element attributes
        for (int i = 0; i < element.getAttributes().getLength(); i++) {
            Node attr = element.getAttributes().item(i);
            currentData.put(element.getTagName() + "@" + attr.getNodeName(), attr.getNodeValue());
        }

        // Process child elements
        NodeList childNodes = element.getChildNodes();
        boolean hasChildElements = false;

        for (int i = 0; i < childNodes.getLength(); i++) {
            Node node = childNodes.item(i);

            if (node.getNodeType() == Node.ELEMENT_NODE) {
                hasChildElements = true;
                flattenXML((Element) node, currentData, printer);
            } else if (node.getNodeType() == Node.TEXT_NODE) {
                String text = node.getTextContent().trim();
                if (!text.isEmpty()) {
                    currentData.put(element.getTagName(), text);
                }
            }
        }

        if (!hasChildElements) {
            printer.printRecord(currentData.values());
        }
    }
}


import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileWriter;
import java.util.LinkedHashMap;
import java.util.Map;

public class XMLToCSVWithXPath {

    public static void main(String[] args) {
        try {
            // Parse the XML file
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse("input.xml");
            Element root = doc.getDocumentElement();

            // Prepare CSV writer
            FileWriter out = new FileWriter("output.csv");
            CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);

            // Flatten XML
            Map<String, String> xPathMap = new LinkedHashMap<>();
            flattenXML(root, "", xPathMap, printer);

            // Write headers
            printer.printRecord(xPathMap.keySet());

            // Write data
            printer.printRecord(xPathMap.values());

            // Close CSV writer
            printer.flush();
            printer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void flattenXML(Element element, String currentPath, Map<String, String> xPathMap, CSVPrinter printer) throws Exception {
        String newPath = currentPath.isEmpty() ? element.getTagName() : currentPath + "/" + element.getTagName();

        // Process element attributes
        for (int i = 0; i < element.getAttributes().getLength(); i++) {
            Node attr = element.getAttributes().item(i);
            String attrPath = newPath + "/@" + attr.getNodeName();
            xPathMap.put(attrPath, attr.getNodeValue());
        }

        // Process child elements
        NodeList childNodes = element.getChildNodes();
        boolean hasChildElements = false;

        for (int i = 0; i < childNodes.getLength(); i++) {
            Node node = childNodes.item(i);

            if (node.getNodeType() == Node.ELEMENT_NODE) {
                hasChildElements = true;
                flattenXML((Element) node, newPath, xPathMap, printer);
            } else if (node.getNodeType() == Node.TEXT_NODE) {
                String text = node.getTextContent().trim();
                if (!text.isEmpty()) {
                    xPathMap.put(newPath, text);
                }
            }
        }

        if (!hasChildElements) {
            // Write the row to the CSV for the current element if it is a leaf node
            printer.printRecord(xPathMap.values());
        }
    }
}


import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.io.FileWriter;
import java.util.LinkedHashMap;
import java.util.Map;

public class XMLToCSVWithXPath {

    public static void main(String[] args) {
        try {
            // Parse the XML file
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse("input.xml");
            Element root = doc.getDocumentElement();

            // Prepare CSV writer
            FileWriter out = new FileWriter("output.csv");
            CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);

            // Write headers
            // Placeholder header generation (adapt as needed)
            printer.printRecord("XPath", "Value");

            // Flatten XML into one row per complete SecLendCommissDetl
            flattenXML(root, "", new LinkedHashMap<>(), printer);

            // Close CSV writer
            printer.flush();
            printer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void flattenXML(Element element, String currentPath, Map<String, String> parentData, CSVPrinter printer) throws Exception {
        String tagName = element.getTagName();
        String newPath = currentPath.isEmpty() ? tagName : currentPath + "/" + tagName;

        // Special handling for SecLendCommissDetl
        if ("SecLendCommissDetl".equals(tagName)) {
            // Accumulate data for current SecLendCommissDetl
            Map<String, String> currentData = new LinkedHashMap<>(parentData);

            // Process element attributes
            for (int i = 0; i < element.getAttributes().getLength(); i++) {
                Node attr = element.getAttributes().item(i);
                String attrPath = newPath + "/@" + attr.getNodeName();
                currentData.put(attrPath, attr.getNodeValue());
            }

            // Process child elements
            NodeList childNodes = element.getChildNodes();
            boolean hasChildElements = false;

            for (int i = 0; i < childNodes.getLength(); i++) {
                Node node = childNodes.item(i);

                if (node.getNodeType() == Node.ELEMENT_NODE) {
                    hasChildElements = true;
                    flattenXML((Element) node, newPath, currentData, printer);
                } else if (node.getNodeType() == Node.TEXT_NODE) {
                    String text = node.getTextContent().trim();
                    if (!text.isEmpty()) {
                        currentData.put(newPath, text);
                    }
                }
            }

            // Write to CSV only when SecLendCommissDetl is fully processed
            if (!hasChildElements) {
                printer.printRecord(currentData.values());
            }
        } else {
            // Process child elements of other tags
            NodeList childNodes = element.getChildNodes();
            for (int i = 0; i < childNodes.getLength(); i++) {
                Node node = childNodes.item(i);

                if (node.getNodeType() == Node.ELEMENT_NODE) {
                    flattenXML((Element) node, newPath, parentData, printer);
                }
            }
        }
    }
}


import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

public class XMLToCSVWithBacktracking {

    public static void main(String[] args) {
        try {
            // Parse the XML file
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse("input.xml");
            Element root = doc.getDocumentElement();

            // Prepare CSV writer
            FileWriter out = new FileWriter("output.csv");
            CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);

            // Write headers
            // Placeholder header generation (adapt as needed)
            printer.printRecord("XPath", "Value");

            // Initialize stack and data structures for backtracking
            Stack<Map<String, String>> stack = new Stack<>();
            stack.push(new LinkedHashMap<>()); // Start with empty map for root
            traverseAndBacktrack(root, "", stack, printer);

            // Close CSV writer
            printer.flush();
            printer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void traverseAndBacktrack(Element element, String currentPath, Stack<Map<String, String>> stack, CSVPrinter printer) throws Exception {
        // Save current state for backtracking
        Map<String, String> currentData = stack.peek();

        String tagName = element.getTagName();
        String newPath = currentPath.isEmpty() ? tagName : currentPath + "/" + tagName;

        // Process element attributes
        for (int i = 0; i < element.getAttributes().getLength(); i++) {
            Node attr = element.getAttributes().item(i);
            String attrPath = newPath + "/@" + attr.getNodeName();
            currentData.put(attrPath, attr.getNodeValue());
        }

        // Process child elements
        NodeList childNodes = element.getChildNodes();
        boolean hasChildElements = false;
        boolean isSecLendCommissDetl = "SecLendCommissDetl".equals(tagName);

        for (int i = 0; i < childNodes.getLength(); i++) {
            Node node = childNodes.item(i);

            if (node.getNodeType() == Node.ELEMENT_NODE) {
                hasChildElements = true;
                if (isSecLendCommissDetl) {
                    // Save current data and push a new map for the next section
                    Map<String, String> newData = new LinkedHashMap<>(currentData);
                    stack.push(newData);
                }
                traverseAndBacktrack((Element) node, newPath, stack, printer);
                if (isSecLendCommissDetl) {
                    // Process and write the data when backtracking from SecLendCommissDetl
                    printer.printRecord(stack.pop().values());
                }
            } else if (node.getNodeType() == Node.TEXT_NODE) {
                String text = node.getTextContent().trim();
                if (!text.isEmpty()) {
                    currentData.put(newPath, text);
                }
            }
        }

        // If this is a leaf node and not SecLendCommissDetl, record the data
        if (!hasChildElements && !isSecLendCommissDetl) {
            printer.printRecord(currentData.values());
        }
    }
}

import java.util.*;

public class XMLBacktrackingProcessor {

    private Set<String> allTags = new HashSet<>();
    private List<Map<String, String>> records = new ArrayList<>();

    public void backtrack(Node node, Map<String, String> currentRecord) {
        if (node == null) return;

        // Process the current node
        String tagName = node.getNodeName();
        String tagValue = node.getTextContent().trim();
        allTags.add(tagName);  // Add the tag to the set of all tags

        currentRecord.put(tagName, tagValue);  // Store the tag value in the current record

        // Recurse over child nodes
        NodeList childNodes = node.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            backtrack(childNodes.item(i), currentRecord);
        }
    }

    public void processDocument(Document xmlDocument) {
        NodeList rootChildren = xmlDocument.getDocumentElement().getChildNodes();
        
        for (int i = 0; i < rootChildren.getLength(); i++) {
            Node child = rootChildren.item(i);
            Map<String, String> currentRecord = new HashMap<>();
            
            // Traverse the child node using backtracking
            backtrack(child, currentRecord);

            // Fill in missing tags with null or empty values
            for (String tag : allTags) {
                currentRecord.putIfAbsent(tag, "null");
            }

            records.add(currentRecord);
        }
    }

    public void outputRecords() {
        // Output all records as pipe-delimited strings
        for (Map<String, String> record : records) {
            StringBuilder recordLine = new StringBuilder();
            for (String tag : allTags) {
                recordLine.append(record.get(tag)).append("|");
            }
            System.out.println(recordLine.toString());
        }
    }

    public static void main(String[] args) {
        // Assume you have parsed the XML into a Document object
        Document xmlDocument = ...; 

        XMLBacktrackingProcessor processor = new XMLBacktrackingProcessor();
        processor.processDocument(xmlDocument);
        processor.outputRecords();
    }
}


import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.util.LinkedHashSet;
import java.util.Set;

public class XMLFieldCollector {

    private Set<String> allFields = new LinkedHashSet<>();  // Use LinkedHashSet to maintain order

    public void collectFields(Node node) {
        if (node == null) return;

        // Add the current node's name to the set
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            allFields.add(node.getNodeName());

            // Add attributes of the node to the set
            NamedNodeMap attributes = node.getAttributes();
            if (attributes != null) {
                for (int i = 0; i < attributes.getLength(); i++) {
                    Node attribute = attributes.item(i);
                    allFields.add(node.getNodeName() + "@" + attribute.getNodeName());
                }
            }
        }

        // Recursively process child nodes
        NodeList childNodes = node.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            collectFields(childNodes.item(i));
        }
    }

    public Set<String> getAllFieldsInOrder(Document xmlDocument) {
        // Start the collection process from the root element
        collectFields(xmlDocument.getDocumentElement());
        return allFields;
    }

    public static void main(String[] args) {
        try {
            // Parse the XML document
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document xmlDocument = builder.parse("path_to_your_xml_file.xml");

            // Create an instance of the field collector
            XMLFieldCollector fieldCollector = new XMLFieldCollector();

            // Get all fields and attributes in order
            Set<String> fieldsInOrder = fieldCollector.getAllFieldsInOrder(xmlDocument);

            // Output the collected fields and attributes
            for (String field : fieldsInOrder) {
                System.out.println(field);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
