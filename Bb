import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.List;

@Service
public class XmlToCsvService {

    @Value("${xml.file.path}")
    private String xmlFilePath;

    @Value("${csv.output.path}")
    private String csvOutputPath;

    @Value("${mongo.connection.string}")
    private String mongoConnectionString;

    @Value("${mongo.database.name}")
    private String mongoDatabaseName;

    @Value("${mongo.collection.name}")
    private String mongoCollectionName;

    public void convertXmlToCsv() throws Exception {
        // Load field mapping from MongoDB
        List<Document> fieldMappings = loadFieldMappingFromMongo();

        // Load XML document
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
        Document doc = dBuilder.parse(new File(xmlFilePath));
        doc.getDocumentElement().normalize();

        try (FileWriter writer = new FileWriter(csvOutputPath)) {
            // Write headers
            List<String> headers = getHeaders(fieldMappings);
            writer.write(String.join("|", headers) + "\n");

            // Loop through each SecLendCommissSection element in the XML
            NodeList sectionNodes = doc.getElementsByTagName("SecLendCommissSection");
            for (int i = 0; i < sectionNodes.getLength(); i++) {
                Element sectionElement = (Element) sectionNodes.item(i);
                String secInstr = getElementValue(sectionElement, "SecInstr");

                NodeList detailNodes = sectionElement.getElementsByTagName("SecLendCommissDetl");
                for (int j = 0; j < detailNodes.getLength(); j++) {
                    Element detailElement = (Element) detailNodes.item(j);

                    List<String> rowData = new ArrayList<>();
                    for (Document fieldMapping : fieldMappings) {
                        String value = "";
                        String xmlTag = fieldMapping.getString("xmlTag");
                        String attribute = fieldMapping.getString("attribute");

                        if (!xmlTag.isEmpty()) {
                            value = getElementValue(detailElement, xmlTag);
                        } else if (!attribute.isEmpty()) {
                            value = detailElement.getAttribute(attribute);
                        }

                        // Handle retaining common fields
                        if (xmlTag.equals("SecInstr")) {
                            value = secInstr;
                        }

                        rowData.add(value);
                    }
                    writer.write(String.join("|", rowData) + "\n");
                }
            }
        }
    }

    private List<Document> loadFieldMappingFromMongo() {
        MongoDatabase database = MongoClients.create(mongoConnectionString).getDatabase(mongoDatabaseName);
        MongoCollection<Document> collection = database.getCollection(mongoCollectionName);
        return collection.find().into(new ArrayList<>());
    }

    private String getElementValue(Element element, String tagName) {
        NodeList nodeList = element.getElementsByTagName(tagName);
        return (nodeList.getLength() > 0) ? nodeList.item(0).getTextContent() : "";
    }

    private List<String> getHeaders(List<Document> fieldMappings) {
        List<String> headers = new ArrayList<>();
        for (Document fieldMapping : fieldMappings) {
            headers.add(fieldMapping.getString("csvHeader"));
        }
        return headers;
    }
}
