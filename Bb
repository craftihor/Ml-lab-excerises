import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.bson.BasicDBObject;

public class AutoborrowCalculationTest {

    private AutoborrowCalculation calculation = new AutoborrowCalculation();

    @Test
    void testCalculate() {
        // Prepare input data
        List<TradeVO> trades = new ArrayList<>();
        TradeVO trade = new TradeVO();
        trade.setData(new BasicDBObject("tradeDate", "Jan 1, 2022 12:00:00 PM EST"));
        trade.setData(new BasicDBObject("tradingType", "AUTO BORROW"));
        trades.add(trade);

        // Execute calculation
        List<TradeVO> result = calculation.calculate(trades);

        // Verify results
        assertNotNull(result);
        assertEquals(1, result.size());
        TradeVO tradeVO = result.get(0);
        BasicDBObject data = tradeVO.getData();
        assertNotNull(data.get("autoborrowAge"));
        assertEquals("AUTOBORROW", data.get("trdCategory"));
    }

    @Test
    void testUpdateAge_ValidDate() {
        // Prepare input data
        BasicDBObject data = new BasicDBObject("tradeDate", "Jan 1, 2022 12:00:00 PM EST");

        // Execute update age
        BasicDBObject result = calculation.updateAge(data);

        // Verify results
        assertNotNull(result);
        assertNotNull(result.get("autoborrowAge"));
    }

    @Test
    void testUpdateAge_InvalidDate() {
        // Prepare input data
        BasicDBObject data = new BasicDBObject("tradeDate", "INVALID_DATE");

        // Execute update age
        BasicDBObject result = calculation.updateAge(data);

        // Verify results
        assertNotNull(result);
        assertEquals(null, result.get("autoborrowAge"));
    }

    @Test
    void testUpdateAge_MissingTradeDate() {
        // Prepare input data
        BasicDBObject data = new BasicDBObject();

        // Execute update age
        BasicDBObject result = calculation.updateAge(data);

        // Verify results
        assertNotNull(result);
        assertEquals(null, result.get("autoborrowAge"));
    }

    @Test
    void testUpdateTrdCategory_ValidType() {
        // Prepare input data
        BasicDBObject data = new BasicDBObject("tradingType", "AUTO BORROW");

        // Execute update trade category
        BasicDBObject result = calculation.updatetrdCategory(data);

        // Verify results
        assertNotNull(result);
        assertEquals("AUTOBORROW", result.get("trdCategory"));
    }

    @Test
    void testUpdateTrdCategory_InvalidType() {
        // Prepare input data
        BasicDBObject data = new BasicDBObject("tradingType", "INVALID_TYPE");

        // Execute update trade category
        BasicDBObject result = calculation.updatetrdCategory(data);

        // Verify results
        assertNotNull(result);
        assertEquals(null, result.get("trdCategory"));
    }

    @Test
    void testUpdateTrdCategory_MissingTradingType() {
        // Prepare input data
        BasicDBObject data = new BasicDBObject();

        // Execute update trade category
        BasicDBObject result = calculation.updatetrdCategory(data);

        // Verify results
        assertNotNull(result);
        assertEquals(null, result.get("trdCategory"));
    }

    @Test
    void testParseDate_ValidDate() {
        // Prepare input data
        String dateString = "Jan 1, 2022 12:00:00 PM EST";

        // Execute parse date
        Date result = calculation.parseDate(dateString);

        // Verify results
        assertNotNull(result);
    }

    @Test
    void testParseDate_InvalidDate() {
        // Prepare input data
        String dateString = "INVALID_DATE";

        // Execute parse date
        assertThrows(ParseException.class, () -> calculation.parseDate(dateString));
    }
}

@Test
    void testExtractFieldsWithXpath() {
        // Prepare JSON template
        String jsonTemplate = "{\"fields\":{\"field1\":{\"position\":1,\"xpath\":\"/root/field1\"},\"field2\":{\"position\":2,\"xpath\":\"/root/field2\"}}}";

        // Execute extraction
        TreeMap<Integer, String> positionToXpath = XMLToCSVWithBacktracking.extractFieldsWithXpath(new JsonObject(jsonTemplate));

        // Verify results
        assertEquals(2, positionToXpath.size());
        assertEquals("/root/field1", positionToXpath.get(1));
        assertEquals("/root/field2", positionToXpath.get(2));
    }

    @Test
    void testTraverseAndBacktrack() throws ParserConfigurationException, SAXException, IOException {
        // Prepare XML file
        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new File("input.xml"));
        Element root = doc.getDocumentElement();

        // Prepare JSON template
        String jsonTemplate = "{\"fields\":{\"field1\":{\"position\":1,\"xpath\":\"/root/field1\"},\"field2\":{\"position\":2,\"xpath\":\"/root/field2\"}}}";

        // Execute traversal
        TreeMap<Integer, String> positionToXpath = XMLToCSVWithBacktracking.extractFieldsWithXpath(new JsonObject(jsonTemplate));
        BufferedWriter writer = new BufferedWriter(new FileWriter("output.csv"));
        XMLToCSVWithBacktracking.traverseAndBacktrack(root, "", new Stack<>(), writer, positionToXpath);

        // Verify results
        writer.close();
        File outputFile = new File("output.csv");
        assertTrue(outputFile.exists());
        assertEquals(2, outputFile.length()); // Assuming 2 rows in the output CSV
    }

    @Test
    void testWriteDataToCSV() {
        // Prepare data
        Map<String, String> data = new LinkedHashMap<>();
        data.put("/root/field1", "value1");
        data.put("/root/field2", "value2");

        // Prepare JSON template
        String jsonTemplate = "{\"fields\":{\"field1\":{\"position\":1,\"xpath\":\"/root/field1\"},\"field2\":{\"position\":2,\"xpath\":\"/root/field2\"}}}";

        // Execute writing
        TreeMap<Integer, String> positionToXpath = XMLToCSVWithBacktracking.extractFieldsWithXpath(new JsonObject(jsonTemplate));
        StringWriter writer = new StringWriter();
        XMLToCSVWithBacktracking.writeDataToCSV(data, writer, positionToXpath);

        // Verify results
        String output = writer.toString();
        assertEquals("value1,value2\n", output);
    }
